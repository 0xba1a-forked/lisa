##############################################################################################
# Run-LisaV2.ps1
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License.
#
<#
.SYNOPSIS
	This is the entrance script for LISAv2.
	LISAv2 is the test framework running Linux test automation on Azure and HyperV platforms,
	including remote test launching in dev system.

.PARAMETER
	See source code for the detailed parameters

.NOTES
	PREREQUISITES:
	1) Prepare necessary 3rd party tools and put them into the Tools folder;
	2) Review the XML configuration files under XML folder and make necessary change for your environment.
	See more from https://github.com/LIS/LISAv2 for helps including README and How-to-use document.

.EXAMPLE
	.\Run-LisaV2.ps1	-TestPlatform "Azure" -TestLocation "westus2" -RGIdentifier "mylisatest"
					-ARMImageName "Canonical UbuntuServer 16.04-LTS latest"
					-XMLSecretFile "C:\MySecrets.xml"
					-TestNames "BVT-VERIFY-DEPLOYMENT-PROVISION"

	.\Run-LisaV2.ps1 -ParametersFile .\XML\TestParameters.xml
	Note: Please refer .\XML\TestParameters.xml file for more details.

#>
###############################################################################################
using Module ".\TestControllers\AzureController.psm1"
using Module ".\TestControllers\HyperVController.psm1"

[CmdletBinding()]
Param(
	#Do not use. Reserved for Jenkins use.
	$BuildNumber=$env:BUILD_NUMBER,

	#[Optional]
	[string] $ParametersFile = "",

	#[Required]
	[ValidateSet('Azure','HyperV', IgnoreCase = $false)]
	[string] $TestPlatform = "",

	#[Required] for Azure.
	[string] $TestLocation="",
	[string] $ARMImageName = "",
	[string] $StorageAccount="",

	#[Required] for HyperV
	[string] $SourceOsVHDPath="",

	#[Required] for Two Hosts HyperV
	[string] $DestinationOsVHDPath="",

	#[Required] Common for HyperV and Azure.
	[string] $RGIdentifier = "",
	[string] $OsVHD = "",   #... [Azure: Required only if -ARMImageName is not provided.]
							#... [HyperV: Mandatory]
	[string] $TestCategory = "",
	[string] $TestArea = "",
	[string] $TestTag = "",
	[string] $TestNames="",
	[string] $TestPriority="",

	#[Optional] Parameters for Image preparation before running tests.
	[string] $CustomKernel = "",
	[string] $CustomLIS,

	#[Optional] Parameters for changing framework behavior.
	[int]    $TestIterations = 1,
	[string] $TiPSessionId,
	[string] $TiPCluster,
	[string] $XMLSecretFile = "",
	[switch] $EnableTelemetry,

	#[Optional] Parameters for Overriding VM Configuration.
	[string] $CustomParameters = "",
	[string] $OverrideVMSize = "",
	[switch] $EnableAcceleratedNetworking,
	[switch] $ForceDeleteResources,
	[switch] $UseManagedDisks,
	[switch] $DoNotDeleteVMs,
	[switch] $DeployVMPerEachTest,
	[string] $VMGeneration = "",

	[string] $ResultDBTable = "",
	[string] $ResultDBTestTag = "",

	[switch] $ExitWithZero
)

# Import the Functions from Library Files.
Get-ChildItem .\Libraries -Recurse | Where-Object { $_.FullName.EndsWith(".psm1") } | `
	ForEach-Object { Import-Module $_.FullName -Force -Global -DisableNameChecking }

try {
	# Generate test log file
	$TestID = New-TestID
	$LogFileName = "LISAv2-Test-$TestID.log"
	Set-Variable -Name LogFileName -Value $LogFileName -Scope Global -Force
	Set-Variable -Name TestID -Value $TestID -Scope Global -Force
	Write-LogInfo "Autogenerated test ID: $TestID"

	# Prepare the workspace
	$MaxDirLength = 32
	$WorkingDirectory = Split-Path -parent $MyInvocation.MyCommand.Definition
	if ( $WorkingDirectory.Length -gt $MaxDirLength) {
		$OriginalWorkingDirectory = $WorkingDirectory
		$WorkingDirectory = Move-ToNewWorkingSpace $OriginalWorkingDirectory | Select-Object -Last 1
	}
	Set-Variable -Name WorkingDirectory -Value $WorkingDirectory  -Scope Global

	# Prepare log folder
	$LogDir = Join-Path $WorkingDirectory "TestResults\$(Get-Date -Format 'yyyy-dd-MM-HH-mm-ss-ffff')"
	New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
	Write-LogInfo "Logging directory: $LogDir"
	Set-Variable -Name LogDir -Value $LogDir -Scope Global -Force

	# Import parameters from file if -ParametersFile is given, and set them as global variables
	$paramTable = @{}
	if ($ParametersFile) {
		$paramTable = Import-TestParameters -ParametersFile $ParametersFile
	}
	# Processing parameters provided in the command runtime
	$paramList = (Get-Command -Name $PSCmdlet.MyInvocation.InvocationName).Parameters;
	foreach ($paramName in $paramList.Keys) {
		$paramObject = Get-Variable -Name $paramName -Scope Script -ErrorAction SilentlyContinue
		$paramValue = $paramObject.Value
		if ($paramValue) {
			if ($paramTable.ContainsKey($paramName)) {
				Write-LogInfo "Overwriting parameter $paramName value: $($paramTable[$paramName]) -> $paramValue"
				$paramTable[$paramName] = $paramValue
			} else {
				Write-LogInfo "Setting parameter: $paramName = $paramValue"
				$paramTable.Add($paramName, $paramValue)
			}
		}
	}

	# Validate test platform, and select test controller of the platform
	$supportedPlatforms = @("Azure", "HyperV")
	if ($paramTable.ContainsKey("TestPlatform")) {
		$TestPlatform = $paramTable["TestPlatform"]
	}
	if ($TestPlatform) {
		if ($supportedPlatforms.contains($TestPlatform)) {
			$testController = New-Object -TypeName $TestPlatform"Controller"
		} else {
			throw "$TestPlatform is not yet supported."
		}
	} else {
		throw "'-TestPlatform' is not provided."
	}

	# Validate the test parameters.
	$testController.ParseAndValidateParameters($paramTable)

	# Handle the Secrets file
	if ($env:Azure_Secrets_File) {
		$XMLSecretFile = $env:Azure_Secrets_File
		Write-LogInfo "The Secrets file is defined by an environment variable."
	}
	$testController.PrepareTestEnvironment($XMLSecretFile)

	# Validate all the XML files and then import test cases from them for test
	Validate-XmlFiles -ParentFolder $WorkingDirectory

	$testController.LoadTestCases($WorkingDirectory, $CustomParameters)

	# Create report folder
	$reportFolder = "$WorkingDirectory\Report"
	if(!(Test-Path $reportFolder)) {
		New-Item -ItemType "Directory" $reportFolder | Out-Null
	}
	$TestReportXml = Join-Path "$reportFolder" "LISAv2_TestReport_$TestID-junit.xml"

	# Create result folder
	$TestResultsDir = "$WorkingDirectory\TestResults"
	if (! (Test-Path $TestResultsDir)) {
		New-Item -ItemType "Directory" $TestResultsDir | Out-Null
	}

	# Run test
	$testController.RunTest($TestReportXml,$TestIterations,$false)
	Write-LogInfo "Test Finished, Test ID: $global:TestID"

	# Output text summary
	$PlainTextSummary = $testController.TestSummary.GetPlainTextSummary()
	Write-LogInfo  "$PlainTextSummary"

	# Zip the test log folder
	$zipFile = "$TestPlatform"
	if ( $TestCategory ) { $zipFile += "-$TestCategory"	}
	if ( $TestArea ) { $zipFile += "-$TestArea" }
	if ( $TestTag ) { $zipFile += "-$($TestTag)" }
	if ( $TestPriority ) { $zipFile += "-$($TestPriority)" }
	$zipFile += "-$TestID-TestLogs.zip"
	$zipFile = $zipFile.Replace("*", "All")
	$zipFilePath = Join-Path (Get-Location).Path $zipFile
	New-ZipFile -zipFileName $zipFilePath -sourceDir $LogDir

	if (Test-Path -Path $TestReportXml ) {
		Write-LogInfo "Analyzing results.."
		$resultXML = [xml](Get-Content $TestReportXml -ErrorAction SilentlyContinue)
		Write-LogInfo "PASS  : $($resultXML.testsuites.testsuite.tests - $resultXML.testsuites.testsuite.errors - $resultXML.testsuites.testsuite.failures)"
		Write-LogInfo "FAIL  : $($resultXML.testsuites.testsuite.failures)"
		Write-LogInfo "ABORT : $($resultXML.testsuites.testsuite.errors)"
		if ( ( $resultXML.testsuites.testsuite.failures -eq 0 ) -and ( $resultXML.testsuites.testsuite.errors -eq 0 ) -and ( $resultXML.testsuites.testsuite.tests -gt 0 )) {
			$ExitCode = 0
		} else {
			$ExitCode = 1
		}
	} else {
		Write-LogErr "Summary file: $TestReportXml does not exist. Exiting with ErrorCode 1."
		$ExitCode = 1
	}
} catch {
	$line = $_.InvocationInfo.ScriptLineNumber
	$script_name = ($_.InvocationInfo.ScriptName).Replace($PWD,".")
	$ErrorMessage =  $_.Exception.Message

	Write-LogErr "EXCEPTION : $ErrorMessage"
	Write-LogErr "Source : Line $line in script $script_name."
	$ExitCode = 1
} finally {
	if ($OriginalWorkingDirectory) {
		Move-BackToOriginalWorkingSpace $WorkingDirectory $OriginalWorkingDirectory $ExitCode
	}
	if ( $ExitWithZero -and ($ExitCode -ne 0) ) {
		Write-LogInfo "Suppress the exit code from $ExitWithZero to 0. (-ExitWithZero specified in command line)"
		$ExitCode = 0
	}
	Get-Variable -Exclude PWD,*Preference,ExitCode | Remove-Variable -Force -ErrorAction SilentlyContinue
	Write-LogInfo "LISAv2 exit code: $ExitCode"

	exit $ExitCode
}
